rules_version = '2';

// Helper function to check if a map contains only specific allowed keys.
function hasOnlyAllowedKeys(map, allowedKeys) {
  return map.keys().removeAll(allowedKeys).size() == 0;
}

// Helper function to check if all affected keys are a subset of allowed keys.
function affectedKeysAreSubset(request, resource, allowedKeys) {
  return request.resource.data.diff(resource.data).affectedKeys().hasOnly(allowedKeys);
}

service cloud.firestore {
  match /databases/{database}/documents {

    // !!! --- PASTE YOUR EXISTING INSTABHARAT /users/... and /posts/... RULES HERE --- !!!
    // It's crucial that your complete, working rules for the existing InstaBharat app
    // are placed in this section. The example below is just a placeholder.

    // START InstaBharat /users collection rules (example placeholder, replace with your actual rules)
    match /users/{userId} {
      allow read: if true; // Public read for user profiles (as per your existing rule for InstaBharat)

      // Scenario 1: User creating their own profile document (e.g., during signup)
      allow create: if request.auth != null && request.auth.uid == userId &&
                       request.resource.data.email == request.auth.token.email &&
                       request.resource.data.username_lowercase == request.resource.data.username.toLowerCase() &&
                       (!('fullName' in request.resource.data) || request.resource.data.fullName_lowercase == request.resource.data.fullName.toLowerCase()) &&
                       request.resource.data.createdAt_ms == request.time.toMillis() &&
                       request.resource.data.updatedAt_ms == request.time.toMillis() &&
                       request.resource.data.postsCount == 0 &&
                       request.resource.data.followersCount == 0 &&
                       request.resource.data.followingCount == 0 &&
                       request.resource.data.likedPostsCount == 0 && // Initialize likedPostsCount
                       request.resource.data.hasActiveStory == false &&
                       hasOnlyAllowedKeys(request.resource.data, [
                         'email', 'username', 'username_lowercase', 'fullName', 'fullName_lowercase',
                         'bio', 'website', 'facebookLink', 'instagramLink', 'interests',
                         'createdAt_ms', 'updatedAt_ms', 'postsCount', 'followersCount', 'followingCount', 'likedPostsCount',
                         'hasActiveStory', 'location', 'pronouns', 'gender',
                         'profilePicURL', 'profilePictureUrls', 'profilePictureStatus', 'profilePicError', 'profilePicLastUpdated_ms'
                       ]);

      // Scenario 2: User updating their own profile (general edit OR specific counter updates)
      allow update: if request.auth != null && request.auth.uid == userId &&
                      (
                        // SCENARIO_PROFILE_EDIT: General profile information update
                        (
                          request.resource.data.username == resource.data.username &&
                          request.resource.data.username_lowercase == resource.data.username_lowercase &&
                          request.resource.data.email == resource.data.email &&
                          // Ensure counters are not changed through this general update path
                          request.resource.data.postsCount == resource.data.postsCount &&
                          request.resource.data.followersCount == resource.data.followersCount &&
                          request.resource.data.followingCount == resource.data.followingCount &&
                          request.resource.data.likedPostsCount == resource.data.likedPostsCount &&
                          request.resource.data.createdAt_ms == resource.data.createdAt_ms &&
                          request.resource.data.updatedAt_ms == request.time.toMillis() &&
                          // Allow only designated profile fields to be part of this general update
                          // Ensure that only the allowed keys are being modified or are present in the diff
                          request.resource.data.diff(resource.data).affectedKeys().hasAny([
                            'fullName', 'fullName_lowercase', 'bio', 'website', 'facebookLink', 'instagramLink', 'interests',
                            'location', 'pronouns', 'gender', 'hasActiveStory', 'updatedAt_ms',
                            'profilePicURL', 'profilePictureUrls', 'profilePictureStatus', 'profilePicError', 'profilePicLastUpdated_ms'
                          ]) &&
                           !request.resource.data.diff(resource.data).affectedKeys().hasAny(['postsCount', 'followersCount', 'followingCount', 'likedPostsCount', 'username', 'username_lowercase', 'email', 'createdAt_ms'])
                        ) ||
                        // SCENARIO_USER_LIKES: User liking/unliking a post (updating likedPostsCount on their own user doc)
                        (
                          request.resource.data.diff(resource.data).affectedKeys().hasOnly(['likedPostsCount', 'updatedAt_ms']) &&
                          (request.resource.data.likedPostsCount == resource.data.likedPostsCount + 1 ||
                           request.resource.data.likedPostsCount == resource.data.likedPostsCount - 1) &&
                          request.resource.data.updatedAt_ms == request.time.toMillis()
                        ) ||
                        // SCENARIO_USER_FOLLOW_UNFOLLOW: User updating their own following/follower counts (e.g., when they follow/unfollow someone)
                        (
                          ( (request.resource.data.followersCount == resource.data.followersCount + 1 || request.resource.data.followersCount == resource.data.followersCount - 1) ||
                            (request.resource.data.followingCount == resource.data.followingCount + 1 || request.resource.data.followingCount == resource.data.followingCount - 1)
                          ) &&
                          request.resource.data.updatedAt_ms == request.time.toMillis() &&
                           request.resource.data.diff(resource.data).affectedKeys().hasAny(['followersCount', 'followingCount', 'updatedAt_ms']) &&
                           !request.resource.data.diff(resource.data).affectedKeys().hasAny(['email', 'username', 'postsCount', 'likedPostsCount', 'bio' /* etc. */])
                        )
                      );

      // Subcollections for followers/following
      match /followers/{followerId} {
        allow read: if true;
        allow create: if request.auth != null && request.auth.uid == followerId &&
                         request.resource.data.userId == followerId &&
                         request.resource.data.followedAt == request.time;
        allow delete: if request.auth != null && request.auth.uid == followerId;
      }
      match /following/{followedUserId} {
        allow read: if true;
        allow create: if request.auth != null && request.auth.uid == userId &&
                         request.resource.data.userId == followedUserId &&
                         request.resource.data.followedAt == request.time;
        allow delete: if request.auth != null && request.auth.uid == userId;
      }
    }
    // END InstaBharat /users collection rules

    // !!! --- PASTE YOUR EXISTING INSTABHARAT /posts/... RULES HERE --- !!!
    // START InstaBharat /posts collection rules (example placeholder, replace with your actual rules)
    match /posts/{postId} {
      allow read: if true; // Public read for posts

      allow create: if request.auth != null && request.auth.uid == request.resource.data.userId &&
                       request.resource.data.likesCount == 0 &&
                       request.resource.data.commentsCount == 0 &&
                       request.resource.data.createdAt == request.time &&
                       request.resource.data.updatedAt == request.time && 
                       request.resource.data.user.username is string &&
                       request.resource.data.mediaUrl is string &&
                       request.resource.data.storagePath is string &&
                       request.resource.data.contentType is string &&
                       request.resource.data.caption is string &&
                       request.resource.data.mediaProcessingStatus == 'pending' &&
                       hasOnlyAllowedKeys(request.resource.data, [
                         'userId', 'user', 'caption', 'mediaUrl', 'storagePath', 'contentType',
                         'aspectRatio', 'mediaProcessingStatus', 'likesCount', 'commentsCount', 'createdAt', 'updatedAt'
                       ]);

      allow update: if request.auth != null &&
                      (
                        (
                          resource.data.userId == request.auth.uid && 
                          request.resource.data.userId == resource.data.userId && 
                          request.resource.data.createdAt == resource.data.createdAt && 
                          affectedKeysAreSubset(request, resource, ['caption', 'updatedAt']) && 
                          request.resource.data.updatedAt == request.time
                        ) ||
                        (
                          affectedKeysAreSubset(request, resource, ['likesCount', 'updatedAt']) &&
                          (request.resource.data.likesCount == resource.data.likesCount + 1 ||
                           request.resource.data.likesCount == resource.data.likesCount - 1) &&
                          request.resource.data.updatedAt == request.time
                        ) ||
                        (
                          affectedKeysAreSubset(request, resource, [
                            'feedImageUrl', 'thumbnailUrl', 'videoPosterUrl',
                            'mediaProcessingStatus', 'mediaProcessingError', 'processedAt', 'updatedAt', 'aspectRatio'
                          ]) &&
                          request.resource.data.updatedAt == request.time
                        )
                      );

      allow delete: if request.auth != null && request.auth.uid == resource.data.userId;

      match /comments/{commentId} {
        allow read: if true;
        allow create: if request.auth != null &&
                         request.resource.data.userId == request.auth.uid &&
                         request.resource.data.createdAt == request.time;
        allow update: if request.auth != null && request.auth.uid == resource.data.userId &&
                         request.resource.data.userId == resource.data.userId &&
                         request.resource.data.createdAt == resource.data.createdAt &&
                         affectedKeysAreSubset(request, resource, ['text', 'updatedAt']) &&
                         request.resource.data.updatedAt == request.time;
        allow delete: if request.auth != null && request.auth.uid == resource.data.userId;
      }

      match /likes/{likeUserId} {
        allow read: if request.auth != null;
        allow create: if request.auth != null && request.auth.uid == likeUserId &&
                         request.resource.data.userId == request.auth.uid &&
                         request.resource.data.createdAt == request.time;
        allow delete: if request.auth != null && request.auth.uid == likeUserId;
      }
    }
    // END InstaBharat /posts collection rules


    // BharatConnect Specific Collections

    // Shadow profiles from InstaBharat
    match /bharatConnectUserShadows/{userId} {
      allow read: if request.auth != null && request.auth.uid == userId;
      allow create: if request.auth != null && request.auth.uid == userId; // User creates their own shadow on first BC interaction
      allow update: if request.auth != null && request.auth.uid == userId; // User might update it if their IB info changes and is re-fetched
      allow delete: if false;
    }

    // Full BharatConnect User Profiles
    match /bharatConnectUsers/{userId} {
      allow read: if request.auth != null && request.auth.uid == userId;

      // TEMPORARY SIMPLIFIED RULE FOR DEBUGGING:
      // Allows create/update if user is authenticated and the UID matches.
      allow create: if request.auth != null && request.auth.uid == userId;
      allow update: if request.auth != null && request.auth.uid == userId;

      // SECURE CREATE RULE (Commented out - Restore after debugging auth issue):
      // allow create: if request.auth != null &&
      //                  request.auth.uid == userId &&
      //                  request.resource.data.id == userId &&
      //                  request.resource.data.email == request.auth.token.email &&
      //                  request.resource.data.onboardingComplete == true &&
      //                  request.resource.data.createdAt != null && 
      //                  request.resource.data.updatedAt != null; 

      // SECURE UPDATE RULE (Commented out - Restore after debugging auth issue):
      // allow update: if request.auth != null &&
      //                  request.auth.uid == userId &&
      //                  request.resource.data.id == userId &&
      //                  request.resource.data.email == resource.data.email && 
      //                  request.resource.data.username == resource.data.username &&
      //                  request.resource.data.createdAt == resource.data.createdAt &&
      //                  request.resource.data.updatedAt != resource.data.updatedAt &&
      //                  (!('onboardingComplete' in request.resource.data) || request.resource.data.onboardingComplete == true);

      allow delete: if false;
    }

    // Add other BharatConnect specific collections here (e.g., chats, messages)
    // Example:
    // match /chats/{chatId} {
    //   // Allow read/write if the user's UID is in the 'participants' array of the chat document
    //   allow read, write: if request.auth != null && request.auth.uid in resource.data.participantsUids;
    //
    //   match /messages/{messageId} {
    //     allow read: if request.auth != null && request.auth.uid in get(/databases/$(database)/documents/chats/$(chatId)).data.participantsUids;
    //     allow create: if request.auth != null && request.auth.uid == request.resource.data.senderId &&
    //                    request.auth.uid in resource.data.participantsUids; // Ensure sender is a participant
    //     // No updates or deletes for messages typically to maintain chat integrity
    //     allow update, delete: if false;
    //   }
    // }

  }
}
